import base64
import re

import frappe
from frappe import _

from india_compliance.gst_india.api_classes.base import (
    BaseAPI,
    change_base_path,
    check_scheduler_status,
)
from india_compliance.gst_india.api_classes.nic.auth import EnrichedAuth, StandardAuth
from india_compliance.gst_india.api_classes.nic.e_waybill_errors import ERRORS_MAP
from india_compliance.gst_india.constants import DISTANCE_REGEX


class EWaybillAPI(BaseAPI):
    API_NAME = "e-Waybill"
    SENSITIVE_INFO = BaseAPI.SENSITIVE_INFO + ("password", "app_key")
    IGNORED_ERROR_CODES = {
        "238": "Invalid auth token",
        #  Cancel e-waybill errors
        "312": "This eway bill is either not generated by you or cancelled",
        #  Error code as per e-Invoice as e-waybill only returns error message
        "604": "E-way bill(s) are already generated for the same document number, you cannot generate again on same document number",
        # Transporter details not found
        "328": "Could not retrieve transporter details from gstin",
    }

    # Response Keys
    AUTH_TOKEN_KEY = "authtoken"
    USER_NAME_KEY = "username"
    PASSWORD_KEY = "password"
    APP_KEY = "app_key"
    DATA_KEY = "data"
    SEK_KEY = "sek"
    REK_KEY = "rek"
    HMAC_KEY = "hmac"

    @classmethod
    def create(cls, *args, **kwargs):
        if cls != EWaybillAPI:
            return cls(*args, **kwargs)

        settings = frappe.get_cached_doc("GST Settings")

        if settings.sandbox_mode or settings.use_fallback_for_nic:
            return EnrichedEWaybillAPI(*args, **kwargs)

        return StandardEWaybillAPI(*args, **kwargs)

    def setup(self, doc=None, *, company_gstin=None):
        self.validate_enable_api()
        check_scheduler_status()

        if doc:
            self.company_gstin = doc.company_gstin
            self.default_log_values.update(
                reference_doctype=doc.doctype,
                reference_name=doc.name,
            )
        else:
            self.company_gstin = company_gstin

    def set_default_headers(self):
        self.default_headers.update(
            {
                "gstin": self.company_gstin,
                "username": self.username,
                "password": self.password,
                "requestid": self.generate_request_id(),
            }
        )

    def validate_enable_api(self):
        if self.settings.enable_e_waybill:
            return

        frappe.throw(_("Please enable e-Waybill features in GST Settings first"))

    def post(self, action, json):
        return super().post(params={"action": action}, json=json)

    def get_transporter_details(self, transporter_id):
        return self.get("GetTransporterDetails", params={"trn_no": transporter_id})

    def is_ignored_error(self, response_json):
        message = response_json.get("message", "")

        for error_code, error_message in self.IGNORED_ERROR_CODES.items():
            if error_message in message:
                response_json.error_code = error_code
                return True

        return False

    def get_e_waybill(self, ewaybill_number):
        action = "getewaybill" if self.sandbox_mode else "GetEwayBill"
        return self.get(action, params={"ewbNo": ewaybill_number})

    def get_e_waybills_by_date(self, date):
        return self.get("GetEwayBillsByDate", params={"date": date})

    def generate_e_waybill(self, data):
        result = self.post("GENEWAYBILL", json=data)
        self.update_distance(result)
        return result

    def cancel_e_waybill(self, data):
        return self.post("CANEWB", json=data)

    def update_vehicle_info(self, data):
        return self.post("VEHEWB", json=data)

    def update_transporter(self, data):
        return self.post("UPDATETRANSPORTER", json=data)

    def extend_validity(self, data):
        return self.post("EXTENDVALIDITY", json=data)

    def update_distance(self, result):
        if (
            (alert := result.get("alert"))
            and "Distance" in alert
            and (distance_match := re.search(DISTANCE_REGEX, alert))
        ):
            result.distance = int(distance_match.group())


class EnrichedEWaybillAPI(EWaybillAPI):
    BASE_PATH = "ewb/ewayapi"

    def setup(self, doc=None, *, company_gstin=None):
        super().setup(doc, company_gstin=company_gstin)

        if self.sandbox_mode:
            self.company_gstin = "05AAACG2115R1ZN"
            self.username = "05AAACG2115R1ZN"
            self.password = "abc123@@"

        else:
            self.fetch_credentials(self.company_gstin, "e-Waybill / e-Invoice")

        self.auth_strategy = EnrichedAuth(self)
        self.set_default_headers()

    @change_base_path("ewb/Master")
    def get_transporter_details(self, transporter_id):
        return super().get_transporter_details(transporter_id)


class StandardEWaybillAPI(EWaybillAPI):
    BASE_PATH = "standard/ewb/ewayapi"

    def setup(self, doc=None, *, company_gstin=None):
        super().setup(doc, company_gstin=company_gstin)

        if not self.company_gstin:
            frappe.throw(_("Company GSTIN is required to use the e-Waybill API"))

        if not frappe.flags.bypass_auth:
            self.fetch_credentials(self.company_gstin, "e-Waybill / e-Invoice")
            self.set_default_headers()

            self.auth_strategy = StandardAuth(self)
            self.auth_strategy.authenticate()

    def _make_request(self, *args, **kwargs):
        response = super()._make_request(*args, **kwargs)

        if isinstance(response, list | tuple):
            return response

        # Invalid Token
        if response.error_code == "238":
            self.auth_token = None
            self.auth_strategy.authenticate()
            response = super()._make_request(*args, **kwargs)

        return response

    @change_base_path("standard/ewb")
    def authenticate(self):
        json_data = {
            "action": "ACCESSTOKEN",
            self.USER_NAME_KEY: self.username,
            self.PASSWORD_KEY: self.password,
            self.APP_KEY: self.app_key,
        }

        return self._make_request("POST", endpoint="auth", json=json_data)

    @change_base_path("standard/ewb/master")
    def get_transporter_details(self, transporter_id):
        return super().get_transporter_details(transporter_id)

    def is_ignored_error(self, response_json):
        error_codes = self._extract_error_codes(response_json)
        if not error_codes:
            return False

        for error_code in error_codes:
            error_code = error_code.strip()
            if error_code in self.IGNORED_ERROR_CODES:
                response_json.error_code = error_code
                response_json.error_message = self.IGNORED_ERROR_CODES[error_code]
                return True

        return False

    def handle_error_response(self, response_json):
        is_success = response_json.get("status") != 0

        if is_success:
            return

        # decode error
        error = base64.b64decode(response_json.error).decode()
        if isinstance(error, str):
            error = frappe.parse_json(error)

        response_json.error = error

        # extract errors
        error_codes = self._extract_error_codes(response_json)
        self.handle_server_error(error_codes)

        if self.is_ignored_error(response_json):
            return

        # throw
        if error_codes:
            error_message = self._format_error_codes(error_codes)
        else:
            error_message = frappe.as_json(response_json, indent=4)

        frappe.throw(
            _("Error generating e-Waybill:<br>{0}").format(error_message),
            title=_("API Request Failed"),
        )

    def _extract_error_codes(self, response_json):
        """Extract error codes from response."""
        error_codes_str = response_json.get("error", {}).get("errorCodes")
        if not error_codes_str:
            return None

        return error_codes_str.split(",")

    def _format_error_codes(self, error_codes):
        """Format error codes into a readable message."""
        error_parts = []
        for code in error_codes:
            code = code.strip()
            error_description = ERRORS_MAP.get(code, code)
            error_parts.append(f"{code}: {error_description}")

        return "<br>" + "<br>".join(error_parts)
